{
"Region of Integration Plotter" : {
    "cat" : [ "Calculus" , "Multivariate" ],
    "descr" : "Plotting regions of integration for iterated triple integrals in different coordinate systems.",
    "code" : [
    "# Limits of the left integral, first bottom, then top.",
    "bot0d = \"1\"",
    "top0d = \"3\"",
    "# Limits of the middle integral.",
    "bot1d = \"1\"",
    "top1d = \"3\"",
    "# Limits of the right integral.",
    "bot2d = \"1\"",
    "top2d = \"3\"",
    "# Function to integrate.",
    "fd = \"1\"",
    "# Order of integration (must match one of the strings in the drop-down list).",
    "dVd = \"dz dy dx\"",
    "# Transparency control: 0 completely clear, 1 completely opaque.",
    "opacity = 0.75",
    "",
    "#########################################",
    "# Copyright (c) 2012 Andrey Novoseltsev #",
    "#########################################",
    "",
    "html(r\"\"\"",
    "<ul>",
    "<li>Consider unchecking <b>Update plot</b> checkbox on the bottom while you are setting up the integral.</li>",
    "<li>On the plot <span style=\"color:red\">red parts</span> correspond to points where limits of the <span style=\"color:red\">red integral</span> are reached, etc.</li>",
    "<li>Try setting equal limits on the internal integral in cylindrical and spherical coordinates to see \"planes parallel to coordinate ones.\"</li>",
    "</ul>",
    "\"\"\")",
    "",
    "def dlist(vs):",
    "    vs = vs.split()",
    "    return [\" \".join(\"d%s\" % v for v in a) for a in Arrangements(vs, len(vs))]",
    "",
    "@interact(layout={",
    "\"top\": [",
    "[\"top0\", \"top1\", \"top2\"],",
    "[\"int0\", \"int1\", \"int2\", \"f\", \"dV\"],",
    "[\"bot0\", \"bot1\", \"bot2\"],",
    "],",
    "\"bottom\": [",
    "[\"plot_axes\", \"plot_origin\", \"update_plot\", \"compute\"],",
    "],",
    "})",
    "def _(",
    "      top0=input_box(label=\"\", default=top0d, type=str, width=5),",
    "      int0=text_control(r\"\"\"<div class=\"math\">\\color{red}{\\int}</div>\"\"\"),",
    "      bot0=input_box(label=\"\", default=bot0d, type=str, width=5),",
    "      top1=input_box(label=\"\", default=top1d, type=str, width=10),",
    "      int1=text_control(r\"\"\"<div class=\"math\">\\color{green}{\\int}</div>\"\"\"),",
    "      bot1=input_box(label=\"\", default=bot1d, type=str, width=10),",
    "      top2=input_box(label=\"\", default=top2d, type=str, width=15),",
    "      int2=text_control(r\"\"\"<div class=\"math\">\\color{blue}{\\int}</div>\"\"\"),",
    "      bot2=input_box(label=\"\", default=bot2d, type=str, width=15),",
    "      f=input_box(label=\"\", default=fd, type=str, width=40),",
    "      dV=selector(dlist(\"x y z\") + dlist(\"z r theta\") + dlist(\"rho phi theta\"), label=\"\", default=dVd),",
    "      plot_axes=checkbox(label=\"Axes:\", default=True),",
    "      plot_origin=checkbox(label=\" Origin:\", default=True),",
    "      update_plot=checkbox(label=\" Update plot:\", default=True),",
    "      compute=checkbox(label=\" Try to compute:\", default=False),",
    "      ):",
    "    vs = [d[1:] for d in dV.split()]",
    "    vs.reverse()",
    "    V = [SR(v) for v in vs]",
    "    v0, v1, v2 = (SR.var(v) for v in vs)",
    "    limits = [eval(\"[v%d, SR(bot%d), SR(top%d)]\" % (i, i, i)) for i in range(3)]",
    "    f(v0, v1, v2) = SR(f)",
    "",
    "    def to_xyz(*V):",
    "        if \"x\" in vs:",
    "            return [V[vs.index(v)] for v in \"xyz\"]",
    "        elif \"r\" in vs:",
    "            r, theta, z = [V[vs.index(v)] for v in [\"r\", \"theta\", \"z\"]]",
    "            return [r*cos(theta), r*sin(theta), z]",
    "        else:",
    "            rho, phi, theta = [V[vs.index(v)] for v in [\"rho\", \"phi\", \"theta\"]]",
    "            return [rho*sin(phi)*cos(theta), rho*sin(phi)*sin(theta), rho*cos(phi)]",
    "",
    "    u = SR.var(\"u\")",
    "    v = SR.var(\"v\")",
    "    p = Graphics()",
    "    V1 = (1-u) * limits[1][1] + u * limits[1][2]",
    "    for i in [1,2]:",
    "        V2 = limits[2][i].subs({v0: v0, v1: V1})",
    "        p += parametric_plot3d(to_xyz(v0, V1, V2), limits[0], (u, 0, 1), opacity=opacity, color=\"blue\")",
    "    for i in [1,2]:",
    "        V1 = limits[1][i]",
    "        V2 = (1-u) * limits[2][1].subs({v1: V1}) + u * limits[2][2].subs({v1: V1})",
    "        p += parametric_plot3d(to_xyz(v0, V1, V2), limits[0], (u, 0, 1), opacity=opacity, color=\"green\", boundary_style={\"color\": \"green\", \"thickness\": 5})",
    "    for i in [1,2]:",
    "        V0 = limits[0][i]",
    "        V1 = (1-u) * limits[1][1].subs({v0: V0}) + u * limits[1][2].subs({v0: V0})",
    "        V2 = (1-v) * limits[2][1].subs({v0: V0, v1: V1}) + v * limits[2][2].subs({v0: V0, v1: V1})",
    "        p += parametric_plot3d(to_xyz(V0, V1, V2), (u, 0, 1), (v, 0, 1), opacity=opacity, color=\"red\", boundary_style={\"color\": \"red\", \"thickness\": 10})",
    "    if plot_origin:",
    "        p += point3d((0, 0, 0), size=25, color=\"yellow\")",
    "    if plot_axes:",
    "        bb = p.bounding_box()",
    "        for i, v in enumerate(\"xyz\"):",
    "            start = min(bb[0][i], 0)",
    "            end = max(bb[1][i], 0)",
    "            length = end - start",
    "            p += line([[0]*i+[start-0.08*length]+[0]*(2-i), [0]*i+[end+0.08*length]+[0]*(2-i)], thickness=3, color=\"brown\")",
    "            p += text3d(v, [0]*i+[end+0.1*length]+[0]*(2-i))",
    "    if update_plot:",
    "        p.show(frame=False, aspect_ratio=1)",
    "    if compute:",
    "        try:",
    "            I2 = integral(f, *(limits[2]))",
    "            I1 = integral(I2, *(limits[1]))",
    "            I0 = integral(I1, *(limits[0]))",
    "            html(r\"\\[ \\iiint_D %s\\, dV = %s \\approx %s \\]\" % tuple(map(latex, [f(v0, v1, v2), I0(0,0,0), I0.n()])))",
    "        except:",
    "            html(r\"\\[ \\iiint_D %s\\, dV = \\dots ? \\]\" % latex(f(v0, v1, v2)))"
    ]
}
}

